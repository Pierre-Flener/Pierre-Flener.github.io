<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="Author" CONTENT="Pierre Flener">
   <TITLE>AUSE Special Issue on Inductive Programming - Call for Papers</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<CENTER><H1><BR><FONT COLOR="#33CC00">
Automated Software Engineering:<BR>
An International Journal
</FONT></H1></CENTER>

<CENTER><H2>
Special Issue on
</H2></CENTER>

<CENTER><H2><FONT COLOR="#33CC00">
Inductive Programming
</FONT></H2></CENTER>

<CENTER><H2>
Guest Editors: Pierre Flener and Derek Partridge
</H2></CENTER>

<hr>

<h2>Aim</h2>

The first step in idealised software engineering is to abstract a precise
specification, which is then taken as the foundation for all subsequent
development, such as coding and testing.  However, complex specifications
typically contain errors and approximations that lead to errors in the
eventual software, errors that are not easily detected or eliminated before
the software is subjected to operational testing.<p>

Many programming problems are manifest as sets of data values, namely
inputs and corresponding outputs.  Inductive programming techniques work
from such data instances to the implementation without going through a
specification.  They thus offer the software engineer a means to avoid or
rectify specification-induced system errors and perhaps even to circumvent
the need for a complete a priori specification, i.e., <I>some</I> system
modules may be inductively generated from data where accurate specification
proves difficult.  Induction-based processing of problem data may be used
to check and correct features of a specification.  Inductive software
development will be particularly germane, if not essential, for complex
data-defined problems, or problem modules.  These will arise in a data-rich
domain and address very complex aspects of the world, such as the human
body, complicated manufacturing processes, and complex dynamical
situations.<p>

Inductive programming is not, however, trouble-free.  There are difficult
issues of `understanding' the automatic induction procedures so that
implementation performance can be characterised.  There are issues of data
pre-processing to facilitate optimal application of a given inductive
technique and to obtain an implementation with certain desired
characteristics.<p>

The aim of this special issue of the
<A HREF="http://www.wkap.nl/journalhome.htm/0928-8910">Automated Software Engineering</A>
journal was to bring together developments in inductive programming that
have a direct bearing on software development.  Papers were sought on novel
uses of such inductive techniques, whether automatic or interactive, for
practical software development.  See the original
<A HREF="cfp.html">Call for Papers</A>
for more details.

<h2>List of Accepted Papers</h2>

<ul>
<li><i>Logic Program Synthesis as Problem Reduction using Combining Forms</i><br>
    Andreas Hamfelt, Jørgen Fischer Nilsson, and Nikolaj Oldager
<li><i>Predictive Software</i><br>
    José Hernández-Orallo and M. José Ramírez-Quintana
<li><i>The Automated Refinement of a Requirements Domain Theory</i><br>
    T. Lee McCluskey and Margaret M. West
</ul>

<h2>Date of Publication</h2>

This special issue was published as Volume 8, Number 2, in April 2001.<p>

A personal viewpoint on
<A HREF="../pub/AUSE01.ps.gz"><I>Inductive Programming</I></A>
by the guest editors was reviewed and added,
with an introduction to the accepted papers.

<p><hr>

<H2>Guest Editors</H2>

Pierre Flener, Uppsala University, Sweden <br>
Derek Partridge, University of Exeter, UK

<P><HR>

</BODY>
</HTML>
