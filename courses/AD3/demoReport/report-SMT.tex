\section*{Problem 4: SAT Modulo Theories (SMT)}

%% Fix below and drop the invocation of the \todo command:
\newcommand{\SolverSMT}{\todo{Z3}\xspace}  % or CVC4, or Yices2, or ...
\newcommand{\TimeoutSMT}{\todo{60.0}}  % timeout, in CPU seconds; MIN 60.0 

\newcommand{\SASM}{\textsf{MiniASM}\xspace}
\newcommand{\Instr}[1]{\mathsf{#1}}
\newcommand{\Cmp}[1]{\Instr{cmp}_{#1}}
\newcommand{\Dup}{\Instr{dup}}
\newcommand{\Jmp}[1]{\Instr{jmp}_{#1}}
\newcommand{\Neg}{\Instr{neg}}
\newcommand{\Plus}{\Instr{plus}}
\newcommand{\Pop}{\Instr{pop}}
\newcommand{\Push}[1]{\Instr{push}_{#1}}
\newcommand{\Read}{\Instr{read}}
\newcommand{\Swap}{\Instr{swap}}
\newcommand{\Write}{\Instr{write}}

\paragraph{Task~a: Encoding of instructions.}
We encode the transition between program states as follows for each
\SASM instruction:
\begin{itemize}
\item $\Push{j}$:
  \begin{itemize}
  \item In English: \todo{\filler}.
  \item In SMT syntax: \todo{\filler}.
  \end{itemize}
\item $\Pop$:
  \begin{itemize}
  \item In English: \todo{\filler}.
  \item In SMT syntax: \todo{\filler}.
  \end{itemize}
\item $\Dup$:
  \begin{itemize}
  \item In English: \todo{\filler}.
  \item In SMT syntax: \todo{\filler}.
  \end{itemize}
\item $\Plus$:
  \begin{itemize}
  \item In English: \todo{\filler}.
  \item In SMT syntax: \todo{\filler}.
  \end{itemize}
\item $\Neg$:
  \begin{itemize}
  \item In English: \todo{\filler}.
  \item In SMT syntax: \todo{\filler}.
  \end{itemize}
\item $\Read$:
  \begin{itemize}
  \item In English: \todo{\filler}.
  \item In SMT syntax: \todo{\filler}.
  \end{itemize}
\item $\Write$:
  \begin{itemize}
  \item In English: \todo{\filler}.
  \item In SMT syntax: \todo{\filler}.
  \end{itemize}
\end{itemize}

\paragraph{Task~b: Partial-correctness checker.}~
\todo{Describe your encoding.}
%
\todo{The final \texttt{assert} call, which ensures that the SMT
  solver produces \texttt{unsat} when needed, is \filler.}

We chose the SMT solver \SolverSMT for our experiments.
%
We chose the programming language \todo{\filler}, for which a compiler
or interpreter is available on the Linux computers of the IT
department.  All source code is \todo{uploaded} with this report (but
not listed inside it).  The compilation and running instructions are
\todo{\filler}.

Let $\Swap$ be the abbreviation of
$\Push{0}; \Write; \Push{1}; \Write; \Push{0}; \Read; \Push{1};
\Read$, that is changing the order of the two top-most numbers on the
stack:
\begin{enumerate}
\item The program $\Push{10}; \Read$ \todo{is or is not} reported by
  \SolverSMT to be partially correct, because \todo{\filler}.
\item The program $\Push{1}; \Dup; \Dup; \Write; \Read$ \todo{\filler}
\item The program $\Push{1}; \Dup; \Read; \Dup; \Neg; \Plus; \Plus$
  \todo{\filler}
\item The program
  $\Push{1}; \Push{0}; \Read; \Write; \Push{0}; \Read; \Read$
  \todo{\filler}
\item The program $\Push{10}; \Push{0}; \Swap$ \todo{\filler}
\item The program
  $\Push{10}; \Dup; \Read; \Swap; \Push{1}; \Plus; \Read; \Plus$
  \todo{\filler}
\item The program
  $\Push{10}; \Dup; \Push{1}; \Plus; \Dup; \Push{1}; \Plus; \Plus;
  \Plus$ \todo{\filler}
\end{enumerate}
When \SolverSMT produces \texttt{sat} for a partial-correctness check,
the output of \texttt{get-model} means \todo{\filler}.

\paragraph{Task~c: Partial-equivalence checker.}~
\todo{Describe your encoding.}
%
\todo{The final \texttt{assert} call, which ensures that the SMT
  solver produces \texttt{unsat} when needed, is \filler.}

We chose the SMT solver \SolverSMT for our experiments.
%
We chose the programming language \todo{\filler}, for which a compiler
or interpreter is available on the Linux computers of the IT
department.  All source code is \todo{uploaded} with this report (but
not listed inside it).  The compilation and running instructions are
\todo{\filler}.

Assuming that variable~$x$ is stored at heap address~$0$ and
variable~$y$ is stored at heap address~$1$, the program
$t \coloneqq x;~ x \coloneqq y;~ y \coloneqq t$, translated into
\[
  \Push{0}; \Read; \Push{1}; \Read; \Push{0}; \Write; \Push{1}; \Write
\]
and the program $x \coloneqq x+y;~ y \coloneqq x-y;~ x \coloneqq x-y$,
translated into
\[
  \Push{0}; \Read; \Push{1}; \Read; \Plus; \Dup; \Push{1}; \Read;
  \Neg; \Plus; \Dup; \Push{1}; \Write; \Neg; \Plus; \Push{0}; \Write
\]
\todo{are or are not} reported by \SolverSMT to be partially
equivalent, because \todo{\filler}.
%
When \SolverSMT produces \texttt{sat} for a partial-equivalence check,
the output of \texttt{get-model} means \todo{\filler}.

\paragraph{Task~d: Extended language.}
We encode the transition between program states for the~$\Cmp{\circ}$
instruction as follows:
\begin{itemize}
\item In English: \todo{\filler}.
\item In SMT syntax: \todo{\filler}.
\end{itemize}
For encoding the $\Jmp{j}$ instruction (where~$j \geq 0$), we propose
\todo{\filler}.
%
The difficulty of encoding one or more $\Jmp{j}$ instructions lies in
\todo{\filler}.
%
With our approach for encoding $\Jmp{j}$, the partial correctness of
programs is determined by \todo{\filler}.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "demoReport"
%%% End:
