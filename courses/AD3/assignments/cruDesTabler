#/usr/bin/python3

#
# Copyright (c) 2022: Frej Knutar Lewander, frej.knutar.lewander@it.uu.se.
# 
# This file is part of course 1DL481 at Uppsala University, Sweden.
# 
# Permission is hereby granted only to the registered students of that
# course to use this file, for a homework assignment.
# 
# The copyright notice and permission notice above shall be included in
# all copies and extensions of this file, and those are not allowed to
# appear publicly on the internet, both during a course instance and
# forever after.
#

# To run this file, you may need to make it executable. On Linux that can be
# done with: chmod +x cruDesTabler

import subprocess
from os import path, mkdir
import logging
import re
import sys
import math
from shutil import which

############################################################################################
#                                   USE AT YOUR OWN RISK!                                  #
############################################################################################
# This is neither tested nor maintained! This script could potentially delete all your     #
# data (or worse) that you spent precious time collecting. I take NO RESPONSIBILITY or     #
# help you use this script in any way!                                                     #
#                                                                                          #
# See NOTES, usage and parameters below if this warning did not deter you.                 #
#                                                                                          #
# NOTE: This program DOES NOT print out memory-outs from minisat, only time-outs.          #
#                                                                                          #
# NOTE: Tested on:                                                                         #
#       minisat version: 1.14 for linux                                                    #
#       python version: 3.6.9                                                              #
#                                                                                          #
# NOTE: this is not tested on the thinlinc clients.                                        #
#                                                                                          #
# NOTE: In order to get full use of this script, then return error codes != 0 when errors, #
#       invalid, or UNSAT was given or generated by cruDes and c cruDesPrint programs      #
############################################################################################

# Usage: ./cruDesTabler [<options>] [<latex_file>]
# Options:
#   --skip-cruDes
#     Skip executing cruDes program
#   --skip-minisat
#     Skip executing minisat
#   --skip-cruDesPrint
#     Skip executing cruDesPrint program
#   --skip-cruDesChecker
#     Skip executing cruDesChecker
#   --skip-writing-latex-results
#     Skip writing the results to the latex file
#   --skip-latex-formatting           
#     Skip formatting the latex file into columns
#
# latex_file:
#     The latex file where output is to be written to, default is "results-SAT.tex"

# For each instance (d, c, e), this program executes:
#  1. 'cruDes d c e > data/cruDes-d-c-e'
#     runs cruDes and outputs the results into the file 'data/cruDes-d-c-e'
#  2. 'minisat data/cruDes-d-c-e solutions/cruDes-d-c-e > logs/cruDes-d-c-e' 
#     runs minisat on the generated model for the instance and writes the results to the
#     file 'solutions/cruDes-d-c-e' and writes the output (STDOUT) to the file 
#     'logs/cruDes-d-c-e'
#  3. 'cat solutions/cruDes-d-c-e | cruDesPrint d c e > solutions/cruDes-d-c-e.txt'
#     runs cruDesPrint on the results from MiniSat that should parse it and convert it
#     to the format that cruDesChecker accepts. The output is written to the file
#     'solutions/cruDes-d-c-e.txt'
#  4. 'cat solutions/cruDes-d-c-e.txt | cruDesChecker c d e'
#     runs cruDesChecker (found here: http://user.it.uu.se/~pierref/courses/AD3/assignments/)
#     on the output from cruDesPrint.
#  5. The data from the log file 'logs/cruDes-d-c-e' is retrieved and appended to the file
#     results-SAT.tex.
#
# Once all instances have terminated, then the file results-SAT.tex is formatted.
# results-SAT.tex can then be used in your Latex report.

############################################################################################
#                                        PARAMETERS                                        #
############################################################################################
# The time-out in seconds.
timeout = 60 #s
# The path to python3
python = which('python3')
# The path to minisat
minisat = path.expanduser('~/.local/bin/minisat')

# If not in the same folder as cruDes, cruDesPrint, or cruDesChecker
# programs, then change these:
cru_des_file_path = path.realpath('cruDes')
cru_des_print_file_path = path.realpath('cruDesPrint')
cru_des_checker_file_path = path.realpath('cruDesChecker')

default_latex_file = 'results-SAT.tex'
# This folder is where the output files from cruDes is stored, it must exist in the same 
# folder as this file.
data_directory = path.realpath('data')

# This folder is where the result files from minisat is stored, it must exist in the same
# folder as this file.
solutions_directory = path.realpath('solutions')

# This folder is where the files storing the output (stdout) from minisat is stored, it 
# must exist in the same folder as this file.
logs_directory = path.realpath('logs')

# Number of decimals in the 'time' column
number_of_decimals = 1
# Number of columns in the latex table
number_of_latex_columns = 3

# Skip increasing the number of evenings for every instance
skip_increasing_e = False
# Skip executing cruDes?
skip_cru_des = False
# Skip executing MiniSat?
skip_minisat = False
# Skip executing cruDesPrint?
skip_cru_des_print = False
# Skip executing cruDesChecker?
skip_cru_des_checker = False
# Skip writing instance results to latex
skip_writing_latex_results = False
# Skip final formatting of latex
skip_latex_formatting = False

# To get get less or more logging information change the logging level
# (logging levels are logging.ERROR, logging.WARNING, logging.INFO, or logging.DEBUG)
logging.basicConfig(level=logging.INFO)

############################################################################################

def popen(args, stdin_file_path=None, stdin_file_mode='r',
          stdout_file_path=None, stdout_file_mode='w+',
          stderr_file_path=None, stderr_file_mode='w+',
          stdin=None, stdout=None, stderr=None,
          timeout=None):
    stdin_is_file = stdin is None and stdin_file_path is not None
    stdout_is_file = stdout is None and stdout_file_path is not None
    stderr_is_file = stderr is None and stderr_file_path is not None
    
    if stdin_is_file:
        stdin = open(stdin_file_path, stdin_file_mode)

    if stdout_is_file:
        stdout = open(stdout_file_path, stdout_file_mode)
    
    if stderr_is_file:
        stderr = open(stderr_file_path, stderr_file_mode)

    process = subprocess.Popen(args, stdin=stdin, stdout=stdout, stderr=stderr)

    try:
        retval = process.wait(timeout=timeout)
    except subprocess.TimeoutExpired:
        process.kill()
        retval = None

    if stdin_is_file:
        stdin.close()
    if stdout_is_file:
        stdout.close()
    if stderr_is_file:
        stderr.close()
    return (process, retval)

def is_minisat_bundled():
    process, _ = popen([minisat, '--help'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    _, output = process.communicate()
    output = output.decode('utf-8')
    regex = re.compile(r'^\s*-cpu-lim\s+')
    return not any((regex.search(line) is not None for line in output.split('\n')))

class Instance:
    def __init__(self, c, d, e, minisat_bundled, skip_cru_des=False, skip_minisat=False,
                 skip_cru_des_print=False, skip_cru_des_checker=False, 
                 skip_writing_latex_results=False, skip_latex_formatting=False):
        self.c = c
        self.d = d
        self.e = e
        self.is_minisat_bundled = minisat_bundled
        self.skip_cru_des = skip_cru_des
        self.skip_minisat = skip_minisat
        self.skip_cru_des_print = skip_cru_des_print
        self.skip_cru_des_checker = skip_cru_des_checker
        self.skip_writing_latex_results = skip_writing_latex_results
        self.skip_latex_formatting = skip_latex_formatting

        self.instance_name = f'cruDes-{d}-{c}-{e}'
        self.logger = logging.getLogger(self.instance_name)

        self.input_file_path = path.join(data_directory, self.instance_name)
        self.result_output_file_path = path.join(solutions_directory, self.instance_name)
        self.solution_file_path = path.join(solutions_directory, self.instance_name + '.txt')
        self.log_file_path = path.join(logs_directory, self.instance_name)

    def execute_cru_des(self):
        self.logger.debug('  | Generating SAT DIMACS for instance...')
        popen(
            [cru_des_file_path, str(self.d), str(self.c), str(self.e)],
            stdout_file_path=self.input_file_path
        )
        self.logger.debug('  | DONE')

    def execute_minisat(self):
        self.logger.debug('  | Running minisat on generated instance...')
        if self.is_minisat_bundled:
            cmd = [minisat, self.input_file_path, self.result_output_file_path]
            minisat_timeout = timeout
        else:
            cmd = [minisat, f'-cpu-lim={timeout}', self.input_file_path, self.result_output_file_path]
            minisat_timeout = None

        (_, retval) = popen(
            cmd,
            stdout_file_path=self.log_file_path,
            timeout=minisat_timeout
        )
        self.logger.debug('  | DONE')
        if retval == 0 or retval is None:
            self.logger.warning('  | Problem instance is indeterminate (most likely due to time-out).')
        elif retval == 10:
            self.logger.debug('  | Problem instance proved satisfiable.')
        elif retval == 20:
            self.logger.debug('  | Problem instance proved unsatisfiable.')

        return retval == 10

    def execute_cru_des_print(self):
        self.logger.debug('  | Printing the solution...')
        popen(
            [cru_des_print_file_path, str(self.d), str(self.c), str(self.e)],
            stdin_file_path=self.result_output_file_path,
            stdout_file_path=self.solution_file_path
        )
        self.logger.debug('  | DONE')
    
    def execute_cru_des_checker(self):
        self.logger.debug('  | Running cruDesChecker...')
        (process, retval) = popen(
            [cru_des_checker_file_path, str(self.d), str(self.c), str(self.e)],
            stdin_file_path=self.solution_file_path,
            stdout=subprocess.PIPE
        )
        self.logger.debug('  | DONE')
        output, _ = process.communicate()
        output = output.decode('utf-8').strip()
        if retval != 0 or output != 'It looks like all is fine for this design!':
            self.logger.error(f'cruDesChecker: {output}')
            return False, output
        return True, output
    
    def write_cru_des_checker_error(self, output):
        self.logger.debug('  | Writing exception to tex...')
        
        message = '\n'.join([
            f"Error for instance d={self.d} c={self.c} e={self.e}.",
            f"Solution file path: {self.solution_file_path}",
            "CruDesChecker output:",
            output
        ])

        with open(latex_file_path, 'w') as latex_file:   
            latex_file.write(message)
        self.logger.debug('  | DONE')

    def is_output_sat(self):
        if not path.isfile(self.result_output_file_path):
            return False
        with open(self.result_output_file_path, 'r') as result_output_file:
            line = next(result_output_file, None)
            return line is not None and line.strip().upper() == 'SAT'        

    def parse_latex_from_log(self):
        time = 't/o'
        trivially_unsat = e > math.floor(float(d - 1) / float(c - 1))
        status = '?' if not trivially_unsat else 'unsat'
        
        if not path.isfile(self.log_file_path):
            return (None, False)
        
        with open(self.log_file_path, 'r') as log_file:
            for line in log_file:
                if len(line) == 0:
                    continue
                if re.search(r'^\s*\s*CPU time\s*:', line) is not None:
                    time_float = float(re.search(r'\d+\.?\d*', line).group())
                    time = f'{{:.{number_of_decimals}f}}'.format(time_float)
                elif re.search(r'^\s*INDETERMINATE', line) is not None:
                    time = 't/o'
                elif re.search(r'^\s*UNSATISFIABLE', line) is not None:
                    status = 'unsat'
                elif re.search(r'^\s*SATISFIABLE', line) is not None:
                    status = 'sat'
        
        data = (
            ' & '.join(map(str, [self.d, self.c, self.e, status, time])) + ' \\\\' +
            (' % trivially' if trivially_unsat else '') + '\n'
        )
        return (data, status == 'sat')

    def write_results_to_latex(self):
        self.logger.debug('  | Parsing minisat output...')
        data, sat = self.parse_latex_from_log()
        if data is not None:
            with open(latex_file_path, 'a') as latex_file:
                latex_file.write(data)
        self.logger.debug('  | DONE')
        return sat
    
    def run(self):
        if not self.skip_cru_des:
            self.execute_cru_des()

        if not self.skip_minisat:
            instance_is_sat = self.execute_minisat()
        else:
            instance_is_sat = self.is_output_sat()

        if instance_is_sat:
            if not self.skip_cru_des_print:
                self.execute_cru_des_print()
            if not self.skip_cru_des_checker:
                success, output = self.execute_cru_des_checker()
                if not success:
                    self.write_cru_des_checker_error(output)
                    exit(1)

        if not self.skip_writing_latex_results:
            instance_is_sat = self.write_results_to_latex()

        return instance_is_sat


def final_latex_formating(latex_file_path):
    with open(latex_file_path, 'r') as latex_file:
        lines = [str(line) for line in latex_file]
    
    prefix = (
        '\\begin{tabular}{rrrrr}\n'+
        '$d$ & $c$ & $e$ & status & time \\\\\n'+
        '\\midrule\n'
    )

    suffix = '\\end{tabular}'

    if len(lines) < number_of_latex_columns or number_of_latex_columns <= 1:
        with open(latex_file_path, 'w') as latex_file:
            latex_file.write(prefix + ''.join(lines) + suffix)
        return

    column_len = math.ceil(len(lines) / number_of_latex_columns)

    line_columns = [
        lines[i:i + column_len] for i in range(0, len(lines), column_len)
    ]

    if len(line_columns[-1]) < column_len:
        line_columns[-1].extend(['\\\\\n'] * (column_len - len(line_columns[-1])))

    seperator_lines = suffix + '\n~~\n' + prefix

    combined_lines = (
        prefix + 
        seperator_lines.join([''.join(line_column) for line_column in line_columns]) + 
        suffix
    )

    with open(latex_file_path, 'w') as latex_file:
        latex_file.write(combined_lines)

if __name__ == '__main__':
    
    logger = logging.getLogger('main')

    exit_with_error = False

    for directory in [data_directory, solutions_directory, logs_directory]:
        if path.isdir(directory):
            continue
        logger.debug(f'Creating {directory}...')
        mkdir(directory)
        if not path.isdir(directory):
            logger.error(f'Directory "{directory}" does not exist and could not be created.')
            exit_with_error = True
            break

    # Get output latex file from argv
    latex_file_path = default_latex_file
    
    if len(sys.argv) > 1:
        file_path = path.abspath(__file__)
        latex_file_path = next(
            (arg for arg in (a.strip() for a in reversed(sys.argv[1:]))
            if len(arg) > 0 and not arg.startswith('-') and path.realpath(arg) != file_path),
            default_latex_file
        )
    
    # Minor sanity check
    if path.isdir(latex_file_path):
        logger.error(f'Latex file path "{latex_file_path}" is a directory.')
        exit_with_error = True
    
    programs = [
        ('cruDes', cru_des_file_path),
        ('cruDesPrint', cru_des_print_file_path),
        ('cruDesChecker', cru_des_checker_file_path)
    ]

    for program_name, program_path in programs:
        if path.isfile(program_path):
            continue
        logger.error(f'Program {program_name} not found at path "{program_path}".')
        exit_with_error = True

    if not path.isfile(minisat) and which(minisat) is None:
        logger.error(f'Program minisat not found at path "{minisat}" nor in path.')
        exit_with_error = True

    if exit_with_error:
        exit(1)

    if len(path.dirname(latex_file_path)) > 0 and not path.isdir(path.dirname(latex_file_path)):
        dirname = path.dirname(latex_file_path)
        
        directories = []
        while len(dirname) > 0 and not path.isdir(dirname):
            directories.insert(0, dirname)
            logger.info(dirname)
            dirname = path.dirname(dirname)
        
        for dirname in directories:
            mkdir(dirname)

        if not path.isdir(path.dirname(latex_file_path)):
            logger.error(f'Directory of resulting latex file {path.dirname(latex_file_path)} does not exist and could not be created.')
            exit(1)

    append_to_latex = len(sys.argv) > 1 and '--append' in sys.argv
    if len(sys.argv) > 1 and '--skip-cruDes' in sys.argv:
        skip_cru_des = True
    if len(sys.argv) > 1 and '--skip-minisat' in sys.argv:
        skip_minisat = True
    if len(sys.argv) > 1 and '--skip-cruDesPrint' in sys.argv:
        skip_cru_des_print = True
    if len(sys.argv) > 1 and '--skip-cruDesChecker' in sys.argv:
        skip_cru_des_checker = True
    if len(sys.argv) > 1 and '--skip-writing-latex-results' in sys.argv:
        skip_writing_latex_results = True
    if len(sys.argv) > 1 and '--skip-latex-formatting' in sys.argv:
        skip_latex_formatting = True

    if not append_to_latex or not path.isfile(latex_file_path):
        if path.isfile(latex_file_path):
            logger.debug('Removing old contents from latex output file')
        else:
            logger.debug('Creating latex output file')
        latex_file = open(latex_file_path, 'w+')
        latex_file.close()
    
    unsat_instances = []
    instances = [
        (8, 2, 7),
        (10, 2, 9),
        (12, 2, 11),
        (14, 2, 12),
        (16, 2, 10),

        (12, 3, 4),
        (15, 3, 6),
        (18, 3, 6),
        (21, 3, 6),
        (24, 3, 6),

        (16, 4, 5),
        (20, 4, 4),
        (24, 4, 4),
        (28, 4, 4),
        (32, 4, 3)
    ]
    logger.info(f" number of instances: {len(instances)}; time-out {timeout} s; Outputting into '{latex_file_path}'.")
    logger.debug(f" checking if minisat is bundled")
    minisat_bundled = is_minisat_bundled()

    for i, (d, c, initial_e) in enumerate(instances):
        e = initial_e
        while e == initial_e or not skip_increasing_e:
            logger.info(f'instance: cruDes-{d}-{c}-{e}')
            
            ins = Instance(
                c,
                d,
                e,
                minisat_bundled,
                skip_cru_des=skip_cru_des,
                skip_minisat=skip_minisat,
                skip_cru_des_print=skip_cru_des_print,
                skip_cru_des_checker=skip_cru_des_checker,
                skip_writing_latex_results=skip_writing_latex_results,
                skip_latex_formatting=skip_latex_formatting
            )

            if not ins.run():
                break

            e += 1
            logger.debug(f'Increasing e to {e}.')

        if e == initial_e:
            logger.warning(f'Time-out or unsat reached for basic problem (d, c, e)=({d}, {c}, {e}).')
            unsat_instances.append((d, c, e))
        else:
            logger.debug(f'Time-out or unsat reached; e will stop increasing for (d, c)=({d}, {c}).')
        logger.info(
            f'{i + 1}/{len(instances)} done ({round(100 * (i + 1) / len(instances), 2)}%).'
        )
    
    if not skip_latex_formatting:
        final_latex_formating(latex_file_path)
    
    if len(unsat_instances) > 0:    
        logger.warning(
            'The following basic problems were not solved: (d, c, e) in [' +
            ', '.join((f'({d}, {c}, {e})' for (d, c, e) in unsat_instances)) +
            '].'
        )
        exit(1)
